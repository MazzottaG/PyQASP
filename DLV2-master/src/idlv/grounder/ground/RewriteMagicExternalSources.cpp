/*******************************************************************************
 *   Copyright 2016 Francesco Calimeri, Davide Fusca', Simona Perri and Jessica Zangari
 *  
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *  
 *        http://www.apache.org/licenses/LICENSE-2.0
 *  
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *******************************************************************************/
/*
 * RewriteMagicExternalSources.cpp
 *
 *  Created on: 04 gen 2017
 *      Author: jessica
 */

#include "RewriteMagicExternalSources.h"
#include "../table/PredicateExtension.h"

namespace DLV2 {
namespace grounder {

RewriteMagicExternalSources* RewriteMagicExternalSources::rewriteMagicExternalSources=nullptr;

void RewriteMagicExternalSources::applyMagicToExternalSources() {
	determineInvolvedVariablesInMagicAtoms();
	set_predicate processedPredicates;

	// For each rule generated by the magic sets technique, check if an external predicate, which is involved in an import directive
	// or in a sparql python external atom, contains a variable present in a magic atom
	for(auto it=StatementDependency::getInstance()->getBeginRules();it!=StatementDependency::getInstance()->getEndRules();++it){
		if(!variablesInMagicAtoms[(*it)->getIndex()].empty()){
			for(auto it2=(*it)->getBeginBody();it2!=(*it)->getEndBody();++it2){
				Atom* atom=(*it2);
				Predicate* predicate=atom->getPredicate();
				if(!atom->isNegative() && predicate!=nullptr  && !(processedPredicates.count(predicate))){
					if(predicatesInImportQueries.count(predicate)){
						for(unsigned i=0;i<atom->getTermsSize();++i){
							if(variablesInMagicAtoms[(*it)->getIndex()].count(atom->getTerm(i))){
								auto pair=variablesInMagicAtoms[(*it)->getIndex()][atom->getTerm(i)];
								predicatesInImportQueries[predicate]->addCondition(i,pair.first,pair.second);
							}
						}
						processedPredicates.insert(atom->getPredicate());
					}
					else if(predicatesInSparqlPythonQueries.count(predicate)){
						for(unsigned i=0;i<atom->getTermsSize();++i){
							if(variablesInMagicAtoms[(*it)->getIndex()].count(atom->getTerm(i))){
								auto pair=variablesInMagicAtoms[(*it)->getIndex()][atom->getTerm(i)];
								Rule* rule=predicatesInSparqlPythonQueries[predicate];
								string query=rule->getAtomInBody(0)->getTerm(0)->getName();
								QuerySPARQL q(query);
								predicatesInImportQueries[predicate]->addCondition(i,pair.first,pair.second);
								Term* newQuery=new StringConstantTerm(false,q.getQuery());
								TermTable::getInstance()->addTerm(newQuery);
								rule->getAtomInBody(0)->setTerm(0,newQuery);
							}
						}
						processedPredicates.insert(atom->getPredicate());
					}
				}
			}
		}
	}
}

} /* namespace grounder */
} /* namespace DLV2 */


